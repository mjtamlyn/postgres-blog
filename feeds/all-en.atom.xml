<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Improved PostgreSQL support for Django</title><link href="http://postgres.mjtamlyn.co.uk/" rel="alternate"></link><link href="http://postgres.mjtamlyn.co.uk/feeds/all-en.atom.xml" rel="self"></link><id>http://postgres.mjtamlyn.co.uk/</id><updated>2014-08-26T00:00:00+01:00</updated><entry><title>Converting database representations</title><link href="http://postgres.mjtamlyn.co.uk/from-db-value.html" rel="alternate"></link><updated>2014-08-26T00:00:00+01:00</updated><author><name>Marc Tamlyn</name></author><id>tag:postgres.mjtamlyn.co.uk,2014-08-26:from-db-value.html</id><summary type="html">&lt;p&gt;I would like to start with an apology for the quietness on this blog recently,
work has been going on though a little slower than I would like as my personal
life has been getting in the way of doing any work. Over the last six weeks
things have improved and there are two exciting new fields in the pipeline.&lt;/p&gt;
&lt;h2&gt;New fields on the way&lt;/h2&gt;
&lt;p&gt;There are 90% finished patches for
&lt;a href="https://github.com/django/django/pull/2923"&gt;UUIDField&lt;/a&gt; and
&lt;a href="https://github.com/django/django/pull/2995"&gt;DurationField&lt;/a&gt;. These fields both
have long standing accepted tickets to be introduced as general django fields,
not specific to PostgreSQL. On PostgreSQL, they will natively use the &lt;code&gt;uuid&lt;/code&gt;
and &lt;code&gt;interval&lt;/code&gt; data types, and on other databases the will use &lt;code&gt;char(32)&lt;/code&gt; and
&lt;code&gt;bigint&lt;/code&gt; respectively. The initial patches used the metaclass &lt;code&gt;SubfieldBase&lt;/code&gt;
provided by Django, but this has some significant issues. As a result, changes
have been needed in the ORM to handle database-python conversions when loading
from the database.&lt;/p&gt;
&lt;h2&gt;The status quo&lt;/h2&gt;
&lt;h3&gt;Database backends&lt;/h3&gt;
&lt;p&gt;Not all database drivers return all field types in the same format. Psycopg2 is
generally pretty well behaved, but mysql, oracle and sqlite all have some
idiosyncrasies about certain fields, usually relating to dates, decimals or
booleans. Furthermore, sometimes these only happened when aggregates were
involved. There were two hooks provided to deal with these, firstly
&lt;code&gt;Query.convert_values&lt;/code&gt; calling &lt;code&gt;DatabaseOperations.convert_values&lt;/code&gt;, which was
called by aggregates code, and secondly the optional method
&lt;code&gt;SQLCompiler.resolve_columns&lt;/code&gt; which was called during normal queryset
evaluation if present. On oracle and in gis, &lt;code&gt;SQLCompiler.resolve_columns&lt;/code&gt;
invoked &lt;code&gt;Query.convert_values&lt;/code&gt; which in turn invoked
&lt;code&gt;DatabaseOperations.convert_values&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This change based on whether &lt;code&gt;SQLCompiler.resolve_columns&lt;/code&gt; existed or not
caused at least &lt;a href="https://code.djangoproject.com/ticket/21565"&gt;ticket 21565&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Custom fields&lt;/h3&gt;
&lt;p&gt;Django provides a metaclass called SubfieldBase, which basically means that
that field will have its &lt;code&gt;to_python()&lt;/code&gt; method called whenever a value is
assigned to the model, including when it is loaded from the database. This
really is an abuse of &lt;code&gt;to_python()&lt;/code&gt; whose primary purpose is to convert strings
from serialisation and forms into the relevant python object. It also provided
no way to change the behaviour based on the backend, but crucially was not
called by aggregation or &lt;code&gt;values()&lt;/code&gt; calls. (&lt;a href="https://code.djangoproject.com/ticket/14462"&gt;ticket
14462&lt;/a&gt;)&lt;/p&gt;
&lt;h3&gt;Proposed changes&lt;/h3&gt;
&lt;p&gt;The new proposed code allows backends and fields to provide converter functions
to transform the value from the database to the model layer. DatabaseBackend
converters are run first and for internal types will normalise the values. A
custom field can then convert the resulting object again if needs be. This code
is run in an efficient manner and the same way in all parts of the ORM -
queries, aggregates, &lt;code&gt;.values()&lt;/code&gt;, &lt;code&gt;.dates()&lt;/code&gt; etc. Due to changes in the
signatures and for performance reasons, all the hooks have changed. The new API
is summarized below:&lt;/p&gt;
&lt;h4&gt;"Private" API&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SQLCompiler.get_converters(fields)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SQLCompiler.apply_converters(row, converters)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;"Semi-Private" API&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;DatabaseOperations.get_db_converters(internal_type)&lt;/code&gt; - returns a list of
    backend converter functions &lt;code&gt;convert(value, field)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Field.get_db_converters(connection)&lt;/code&gt; - returns a list of field converter
    functions &lt;code&gt;convert(value, field)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Public API&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Field.from_db_value(value, connection)&lt;/code&gt; - public documented hook to replace
    SubfieldBase.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;A note on gis&lt;/h2&gt;
&lt;p&gt;This has a 147 line negative diff in &lt;code&gt;contrib.gis&lt;/code&gt;, removing a bunch of
duplicated code, an entire compiler module for mysql, &lt;code&gt;GeoValuesQuerySet&lt;/code&gt;, and
custom code in &lt;code&gt;SQLDateCompiler&lt;/code&gt;. Overall it is a pretty substantial cleanup
and the proposed API is nicely overridable by the gis compiler.&lt;/p&gt;
&lt;h2&gt;Comments&lt;/h2&gt;
&lt;p&gt;The proposed changes are available as a &lt;a href="https://github.com/django/django/pull/3047"&gt;pull
request&lt;/a&gt; for comment, and there is
also a &lt;a href="https://groups.google.com/forum/#!msg/django-developers/0nauqFFwscU/ykXvUTkxW0wJ"&gt;thread on
Django-Dev&lt;/a&gt;&lt;/p&gt;</summary><category term="django"></category><category term="postgres"></category><category term="kickstarter"></category></entry><entry><title>Arrays merged</title><link href="http://postgres.mjtamlyn.co.uk/arrays-merged.html" rel="alternate"></link><updated>2014-05-23T00:00:00+01:00</updated><author><name>Marc Tamlyn</name></author><id>tag:postgres.mjtamlyn.co.uk,2014-05-23:arrays-merged.html</id><summary type="html">&lt;p&gt;Good news everyone! &lt;code&gt;ArrayField&lt;/code&gt; has been merged into django master. This
will not be backported to the upcoming 1.7 release, but it will now be in 1.8.
You can read the
&lt;a href="https://docs.djangoproject.com/en/dev/ref/contrib/postgres/"&gt;documentation&lt;/a&gt;.
Let us know if you find any errors!&lt;/p&gt;
&lt;p&gt;There are two notable areas which still need to be addressed with arrays, but
the patch was large enough to review and merge without those as well. The first
is improving its behaviour in the admin. I would like to provide an admin
widget which uses the normal admin widgets for each field, starting with a
given number but also being extended to arbitrary size by an "add" button on
the page. This extension is rather difficult to implement at present because of
most of the django admin widgets are not easily constructible from javascript.
In order to do this well, a fairly significant overhaul of how the Django admin
renders widgets such as the date/time widget and makes them interactive is
needed.&lt;/p&gt;
&lt;p&gt;The second area is indexing. While &lt;code&gt;db_index=True&lt;/code&gt; will work on an
&lt;code&gt;ArrayField&lt;/code&gt;, it will create a btree index which is only useful for equality
in this case. The correct index type is a &lt;code&gt;gist&lt;/code&gt; index, but there is no way to
tell Django this is what I need. This will require a refactoring of
&lt;code&gt;spatial_index&lt;/code&gt; in &lt;code&gt;contrib.gis&lt;/code&gt; as well, and fits nicely within the work on
custom indexes.&lt;/p&gt;
&lt;p&gt;I think my next area to work on will be uuid fields, with larger primary key
fields coming out as a corrollary. The interest here will be in supporting
making fields other than &lt;code&gt;AutoField&lt;/code&gt; be "auto" fields - using &lt;code&gt;RETURNING&lt;/code&gt; to
allow the database to calculate their values and return them.&lt;/p&gt;
&lt;p&gt;For those interested, slides from my talk at DjangoConEurope are &lt;a href="https://speakerdeck.com/mjtamlyn/the-future-of-postgresql-in-django"&gt;available
online&lt;/a&gt;.&lt;/p&gt;</summary><category term="django"></category><category term="postgres"></category><category term="kickstarter"></category></entry><entry><title>Fields of fields</title><link href="http://postgres.mjtamlyn.co.uk/arrays.html" rel="alternate"></link><updated>2014-04-08T00:00:00+01:00</updated><author><name>Marc Tamlyn</name></author><id>tag:postgres.mjtamlyn.co.uk,2014-04-08:arrays.html</id><summary type="html">&lt;p&gt;I'm sure you will all be pleased to hear that some progress is being made with
the project! The bulk of the work will be done over the summer months, but I am
hoping to have a couple of the more interesting new field types done before
&lt;a href="http://2014.djangocon.eu/"&gt;DjangoConEU&lt;/a&gt; in May. (Speaking of DjangoConEU - I
will be speaking in more detail there about this project, if you haven't booked
your tickets yet you should totally do so - it'll be a great event!)&lt;/p&gt;
&lt;p&gt;There is now a "work in progress" &lt;a href="https://github.com/django/django/pull/2485"&gt;pull
request&lt;/a&gt; available on github for
array fields. Comment is very welcome! An array field allows you to store lists
of data in a single field. It's like the big brother of Django's
&lt;a href="https://docs.djangoproject.com/en/dev/ref/models/fields/#commaseparatedintegerfield`"&gt;&lt;code&gt;CommaSeparatedIntegerField&lt;/code&gt;&lt;/a&gt;,
but it supports most other field types underneath.&lt;/p&gt;
&lt;p&gt;The only restriction on the field type is that we do not support any related
field type - &lt;code&gt;ForeignKey&lt;/code&gt; or &lt;code&gt;ManyToMany&lt;/code&gt;. I should not need to explain why the
latter is illogical, but in the case of the former it's worth pointing out the
reasoning why. In short, Postgres does not allow the use of &lt;code&gt;REFERENCES&lt;/code&gt; in
array field declarations, so you could build an array of foreign key data, but
it would not have referential integrity. As this is a promise of the
&lt;code&gt;ForeignKey&lt;/code&gt;, we cannot support &lt;code&gt;ArrayField(ForeignKey())&lt;/code&gt;. This is an
unfortunate restriction as many of the "natural" use cases for arrays would
reference other objects, and one which I hope to lift in the future if Postgres
support improves. You can of course emulate this with
&lt;code&gt;ArrayField(IntegerField())&lt;/code&gt; but this is at your own risk!&lt;/p&gt;
&lt;p&gt;Aside from their utility for storing list-like data without the requirement for
another table, Postgres array fields can also be queried in a number of ways.
Taking as an example a dice-based guessing game where we have an &lt;code&gt;Attempt&lt;/code&gt; model
which stores the attempts to guess the rolled number, the following queries are
all valid:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Attempt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;objects&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;filter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;guesses&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;  &lt;span class="c"&gt;# only one guess, value 1&lt;/span&gt;
&lt;span class="n"&gt;Attempt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;objects&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;filter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;guesses__0&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c"&gt;# first guess is 1&lt;/span&gt;
&lt;span class="n"&gt;Attempt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;objects&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;filter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;guesses__0_1&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;  &lt;span class="c"&gt;# first guess 1, second guess 2&lt;/span&gt;
&lt;span class="n"&gt;Attempt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;objects&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;filter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;guesses__len__lt&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c"&gt;# less than 3 guesses&lt;/span&gt;
&lt;span class="n"&gt;Attempt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;objects&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;filter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;guesses__contains&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;  &lt;span class="c"&gt;# at least one guess is 1&lt;/span&gt;
&lt;span class="n"&gt;Attempt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;objects&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;filter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;guesses__overlap&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;  &lt;span class="c"&gt;# at least one guess is either 1 or 2&lt;/span&gt;
&lt;span class="n"&gt;Attempt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;objects&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;filter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;guesses__contained_by&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;  &lt;span class="c"&gt;# guesses include only 1 and 2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;As with other non-text based fields in Django, at the moment array fields still
support a number of other lookups which cast the value to text. Personally I
consider this to be somewhat misleading at the moment and am considering
removing support for them. This is perhaps part of a wider question though - is
it logical that a &lt;code&gt;DateField&lt;/code&gt; supports &lt;code&gt;__istartswith&lt;/code&gt; (probably not) but is it
logical that it supports &lt;code&gt;__startswith=200&lt;/code&gt; as an alternative to the upcoming
(postgres specific) &lt;code&gt;__decade=2000&lt;/code&gt;? My instinct is that we should introduce a
&lt;code&gt;__text&lt;/code&gt; transform which is available on all data types and casts to text,
allowing these filters. This could be done with a deprecation path. I'm
interested to hear your views!&lt;/p&gt;
&lt;p&gt;The next step is to build a couple of form fields for arrays, one being a
simple CharField taking a &lt;code&gt;delimiter&lt;/code&gt; with a delimiter to split on, and the
other being a more complex Javascript enabled field for the admin which allows
a nicer interface. Perhaps we could also include a version of this without the
javascript that has a similar API to formsets. After that I just need to write
complete documentation and we can merge it in!&lt;/p&gt;
&lt;h2&gt;A note on JSON support&lt;/h2&gt;
&lt;p&gt;The Postgres team have recently merged support for a &lt;code&gt;jsonb&lt;/code&gt; datatype - binary
stored JSON. It is quite likely that I will delay JSON support until Postgres
9.4 is out and only support the &lt;code&gt;jsonb&lt;/code&gt; data type. There are several reasons
for this, the most significant being that the current &lt;code&gt;json&lt;/code&gt; data type is
severly limited in its implementation, lacking even an equality operator. This
means that some parts of Django annotation code generate invalid queries (see
&lt;a href="https://github.com/bradjasper/django-jsonfield/issues/55"&gt;this report&lt;/a&gt;) and
also means that a &lt;code&gt;__exact&lt;/code&gt; lookup has to be forbidden. To handle all these
edge cases properly in Django would result in a huge amount of complexity, and
the benefits you gain over just storing json in a text field are actually quite
limited. 9.4 is due out towards the end of this year, so as a result JSON
fields are likely to only feature in the 1.8 release.&lt;/p&gt;
&lt;h2&gt;Sponsors page updated&lt;/h2&gt;
&lt;p&gt;The &lt;a href="/pages/sponsors.html"&gt;sponsors page&lt;/a&gt; has been updated with images and
links for all the major sponsors. Go and check out all the great companies and
individuals who have supported this project.&lt;/p&gt;</summary><category term="django"></category><category term="postgres"></category><category term="kickstarter"></category></entry><entry><title>Making a start</title><link href="http://postgres.mjtamlyn.co.uk/where-to-start.html" rel="alternate"></link><updated>2014-03-15T00:00:00+00:00</updated><author><name>Marc Tamlyn</name></author><id>tag:postgres.mjtamlyn.co.uk,2014-03-15:where-to-start.html</id><summary type="html">&lt;p&gt;The last month has been amazing for me. It feels like the whole Django
community has got behind this project and is looking forwards to it. An
enormous thank you to everyone who has contributed to the project. I am still
gathering together the details of the sponsors, but you can see a "raw" list on
&lt;a href="/pages/sponsors.html"&gt;this site&lt;/a&gt;. In particular, I'd like to thank the DSF,
Django stars, Judicata and Tangent Labs for their particularly generous
donations, but without all of you, none of what I'm about to do would be
possible.&lt;/p&gt;
&lt;p&gt;I've made a start writing some code. Easily one of the most popular features is
hstore. For those who might not be familiar, a postgres hstore is a bit like a
simple dictionary in a column - it contains a mapping of strings to strings.
They are one dimensional and completely free form - there is no guarantee about
which keys might exist. They are a really great way to add a small amount of
unstructured data to a model without making schema changes. You might be
tempted to just use json for this sort of functionality, but unless you need
the nested structures, hstore is much more powerful for querying and indexing.&lt;/p&gt;
&lt;p&gt;The problem with hstore is that it requires an extension. This is pretty
straightforwards for a production database - just type &lt;code&gt;CREATE EXTENSION
hstore&lt;/code&gt; at the prompt in that database once (before creating the tables) and
you're good to go. Where it becomes a problem for us is in testing - the newly
created test database does not have the &lt;code&gt;hstore&lt;/code&gt; extension. It would also be
nice if you didn't have to log on to your shell and run the &lt;code&gt;CREATE EXTENSION&lt;/code&gt;
directly, it was just created if you have a model using hstore.&lt;/p&gt;
&lt;p&gt;There are a few possible ways to acheive this using the new migrations
framework. The first (for which there is a &lt;a href="https://github.com/django/django/pull/2266"&gt;proposed
patch&lt;/a&gt;) is to extend
&lt;code&gt;Field.db_parameters()&lt;/code&gt; to allow it to return some &lt;code&gt;pre_create_sql&lt;/code&gt;, which will
be run every time a field of this type is created (either by adding a model
using the field, or by adding a field of this type to an already existing
model). This means the sql might be run many times and needs to be coded
defensively - that is use &lt;code&gt;CREATE EXTENSION IF NOT EXISTS&lt;/code&gt;. Whilst this patch
works, it introduces potentially a large number of unnecessary SQL statements
run against the database, and it also has no way to remove any extension if it
is no longer needed.&lt;/p&gt;
&lt;p&gt;An alternative is to create an initial migration in the postgres app which will
create all the necessary extensions that might be needed for all parts of the
app. This has a major drawback which is that it would create extensions even if
the project does not use that part of the code. As some extensions could
conceivably only for for some versions of PostgreSQL, these migrations might
not even work for all users.&lt;/p&gt;
&lt;p&gt;Another alternative is to introduce a new concept called an &lt;code&gt;Extension&lt;/code&gt; which
would be tracked by the autodetector for migrations. I'm going to try to create
a concrete patch for this to see how complex it is, but the idea does have some
usage outside of postgres as a means of allowing certain models or field types
to require custom functions to be created in the database, something which all
the supported databases have.&lt;/p&gt;
&lt;p&gt;This is going to take some time to get right, so in the mean time I'm going to
make a start on array fields. They're possibly my favourite feature in the
entire project and something I know I have half a dozen concrete use cases for.
One of the most interesting things about them is that they can be created for
almost any django field type (with the notable exception of
&lt;code&gt;ManyToManyField&lt;/code&gt;!), so there's a lot of possible edge cases, especially in the
admin widget. It will also be the first core field to have dynamic custom
lookups - a syntax along the lines of &lt;code&gt;.filter(myarray__0=17)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;First things first however is the get the beta of 1.7 out of the door and get
the branch away for master. This will then allow me to start merging new
features into Django master. As always, community help with reviewing
prereleases of Django is enormously beneficial for the core team, so please do
go and download the new versions and test them out - there are loads of awesome
new features in 1.7!&lt;/p&gt;</summary><category term="django"></category><category term="postgres"></category><category term="kickstarter"></category></entry><entry><title>A wild Kickstarter appears!</title><link href="http://postgres.mjtamlyn.co.uk/launch.html" rel="alternate"></link><updated>2014-02-08T00:00:00+00:00</updated><author><name>Marc Tamlyn</name></author><id>tag:postgres.mjtamlyn.co.uk,2014-02-08:launch.html</id><summary type="html">&lt;p&gt;I love Django. I also love PostgreSQL.&lt;/p&gt;
&lt;p&gt;I've been fortunate enough to hear Craig Kersteins and Christophe Pettus talk
several times about how wonderful Postgres is. I've come away from Django
conferences filled with enthusiasm for the promised land of database
specificity, of semi-flexible schemas using hstore, of array fields, of json in
my database, of full text search and functional indexes and materialized views
andâ€¦ all the other wonderful features offered by Postgres.&lt;/p&gt;
&lt;p&gt;Then I go looking for third party packages to use these features. The state of
hstore is pretty good - I can install the &lt;code&gt;django-hstore&lt;/code&gt; package, add a model
and a custom manager to my model and everything works, even the admin. The API
for filtering is pretty good, I get some interesting atomic operations to
update keys via the custom manager, and there's even an interesting subclass
which extends the API to reference other model instances as the values. It's
not all perfect - the API could be more natural in some places (e.g.
&lt;code&gt;.filter(data__mykey=value)&lt;/code&gt; rather than &lt;code&gt;.filter(data__contains({'mykey':
'value'})&lt;/code&gt; - but we are pretty much there.&lt;/p&gt;
&lt;p&gt;What about arrays? Well according to django packages there are &lt;a href="https://www.djangopackages.com/grids/g/arrayfield/"&gt;several
different implementations&lt;/a&gt;,
none of which have Python3 support, none of which are currently actively
developed, and most of which don't even have documentation. Alternatively,
there's &lt;a href="https://github.com/niwibe/djorm-ext-pgarray"&gt;djorm-ext-pgarray&lt;/a&gt; which
is better, but it still requires me to understand how to use array fields in
SQL - I need to know what &lt;code&gt;@&amp;gt;&lt;/code&gt; means, using &lt;code&gt;SqlExpression&lt;/code&gt; objects in
&lt;code&gt;.where()&lt;/code&gt; clauses to build my queries. I need to know the postgres name for
the underlying database field I want to use. That's not the ORM I love.&lt;/p&gt;
&lt;p&gt;Now, I do not wish to appear too harsh on the developers of these pacakges and
others. Django has in no way helped them make it easy to provide nice APIs. The
custom field syntax is quite limited, only really allowing you to change the
mapping between the database structure and the python structure, and changing
the &lt;code&gt;db_type&lt;/code&gt; to modify creation. This gets a lot better in Django 1.7 as we
now have &lt;a href="https://docs.djangoproject.com/en/dev/ref/models/custom-lookups/"&gt;custom lookups and
transforms&lt;/a&gt;,
although they currently only work in &lt;code&gt;.filter()&lt;/code&gt; clauses. In particular, I'd
like to thank &lt;a href="https://github.com/niwibe"&gt;Andrey Antukh&lt;/a&gt; for his work on the
&lt;code&gt;pg-ext-*&lt;/code&gt; collection of packages, which have working implementations of most
of the features I wish to build directly into Django.&lt;/p&gt;
&lt;p&gt;That said, we can do better. Several people I've worked with, who I consider to
be very good Django developers, have absolutely no idea how to go about
constructing complex SQL queries by hand. Ask what the difference is between
a left and a right outer join and you'll just get a blank expression. Whilst
it's easy to be snarky about this and claim it's a failing in their education,
I prefer to see it as a huge compliment for the power of the Django ORM. These
people have managed to write numerous successful websites with the database at
the core of the functionality, without knowing how to interact with their
database directly. I would like the more advanced postgres features to have the
same ease of use.&lt;/p&gt;
&lt;p&gt;Whilst in Warsaw at the wonderful &lt;a href="http://2013.djangocon.eu/"&gt;Django Circus&lt;/a&gt;
conference last summer, I chatted a bit to members of the core team about this
concept, and the general state of postgres support in the community. There was
agreement that it was not ideal, and we could do better. The idea formed in my
head that we could build first class support for these features into Django
itself, with the understanding that using database specific functionality is
perfectly reasonable (if not required) for any large site.&lt;/p&gt;
&lt;p&gt;So I've decided to do something about it. The core team and the DSF have given
their backing for me to do exactly that - build first class support for
PostgreSQL specific features into Django. This will be as a new contrib module
- &lt;code&gt;django.contrib.postgres&lt;/code&gt;. This is not a small undertaking I can write in an
odd evening or weekend. I'm going to need your help to allow me to spend enough
time on it to make it good. To that end, and inspired by Andrew Godwin's
&lt;a href="http://www.kickstarter.com/projects/andrewgodwin/schema-migrations-for-django"&gt;success with
migrations&lt;/a&gt;,
I'm launching a Kickstarter hopefully at some point in the next week. The
initial aim is to ensure that most Postgres data types have a good Django
equivalent, and for full text search to be possible. With more funding, I'll
also make date based queries much more powerful, add dozens of postgres
specific functions as custom transforms and lookups, and add support for custom
indexes and views. It will take time to build all of this, but I'm confident at
least some features will land for Django 1.8, with most of the rest in Django
1.9.&lt;/p&gt;
&lt;p&gt;For reference, this is what I currently consider as the list of things each
field will need to be considered fully supported:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The field implementation itself, with appropriate keyword arguments to
  provide the same level of expression as the raw SQL equivalent&lt;/li&gt;
&lt;li&gt;Support for "standard" filters such as &lt;code&gt;__contains&lt;/code&gt;, &lt;code&gt;__lt&lt;/code&gt; etc if
  appropriate&lt;/li&gt;
&lt;li&gt;Support for appropriate custom filtering methods specific to the data type&lt;/li&gt;
&lt;li&gt;A usable, javascript-free form field&lt;/li&gt;
&lt;li&gt;Where appropriate, a cleverer custom widget for use in the admin&lt;/li&gt;
&lt;li&gt;Extensive tests for each field covering field creation and modification via
  migrations, all allowable query constructs and validation&lt;/li&gt;
&lt;li&gt;Documentation for the model field and form field, complete with examples and
  comments on possible use cases.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Thanks for reading, and I hope you are as excited by this project as I am!&lt;/p&gt;</summary><category term="django"></category><category term="postgres"></category><category term="kickstarter"></category></entry></feed>